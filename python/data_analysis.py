"""
This module contains function to read and work with cif files gemmi outputs and the yell format
"""
import re
import os
import subprocess
import numpy as np
import h5py


class Diffraction:
    """
    A class for holding, accessing and converting Diffraction data
    """

    def __init__(
        self,
        frac_hkl_max: np.ndarray,
        intensities: np.ndarray,
        super_cells: np.ndarray,
    ):
        self.frac_hkl_max = np.array(frac_hkl_max)
        self.intensities = intensities
        self.super_cells = super_cells

    @classmethod
    def add_from_files(cls, paths: list[str], supercells: np.ndarray):
        """
        reads the list of sf files provided and adds the values
        failes if the (hkl) have different ranges
        """
        first_int_hkl, summed_intensities = read_sf_file(paths[0])
        for path in paths[1:]:
            int_hkl, intensities = read_sf_file(path)
            assert (first_int_hkl == int_hkl).all()
            summed_intensities += intensities

        int_hkl_max, intensities = Diffraction.bring_into_shape(
            first_int_hkl, summed_intensities
        )
        return cls(int_hkl_max / supercells, intensities, supercells)

    @classmethod
    def read_sf(cls, path: str, supercells: np.ndarray):
        """
        reads an .sf file
        """
        int_hkl, intensities = read_sf_file(path)
        int_hkl_max, intensities = Diffraction.bring_into_shape(int_hkl, intensities)
        return cls(int_hkl_max / supercells, intensities, supercells)

    @staticmethod
    def bring_into_shape(
        integer_hkls: np.ndarray, intensities: np.ndarray
    ) -> tuple[np.ndarray, np.ndarray]:
        """
        Takes the integer hkl and intensitied as generated by gemmi
        and puts the intensities into the correct shape
        """
        int_hkl_max = np.amax(np.abs(integer_hkls), axis=0)

        int_h_max, int_k_max, int_l_max = int_hkl_max
        new_intensities = np.empty(int_hkl_max * 2 + 1)
        new_intensities[:] = np.nan
        for (h, k, l), intensitiy in zip(integer_hkls, intensities):
            new_intensities[int_h_max + h, int_k_max + k, int_l_max + l] = intensitiy
            new_intensities[int_h_max - h, int_k_max - k, int_l_max - l] = intensitiy
        return np.array([int_h_max, int_k_max, int_l_max]), new_intensities

    def has_nan(self) -> bool:
        """
        checks if the diffraction data has nan
        """
        return np.isnan(self.intensities).all()

    def plot_l_section(self, fig, ax, l_value):
        """
        plots an l-section if the diffraction data
        """
        int_l_value = int(round(l_value * self.super_cells[2]))
        int_h_max, int_k_max, int_l_max = np.round(
            self.frac_hkl_max * self.super_cells
        ).astype(np.int32)
        section = self.intensities[:, :, int_l_max + int_l_value]

        im = ax.imshow(
            section,
            extent=[
                -int_h_max,
                int_h_max,
                -int_k_max,
                int_k_max,
            ],
            cmap="gray",
        )
        fig.colorbar(im)
        fig.tight_layout()

    def save_yell(self, path):
        """
        saves the diffraction pattern into the yell format (a .h5 file)
        """
        output = h5py.File(path, "w")
        output["data"] = self.intensities  # the data
        output["format"] = b"Yell 1.0"  # formatting string
        # whether the data is in real or reciprocal space. Scattering data is in reciprocal space
        output["is_direct"] = 0
        # the smallest hkl index for this dataset respecting supercells fractional values
        output["lower_limits"] = -self.frac_hkl_max
        output["step_sizes"] = 1 / self.super_cells
        output["unit_cell"] = [10.0003, 10.0003, 10.0003, 90, 90, 90]
        output.close()

    @classmethod
    def open_yell(cls, path):
        """
        reads the data from a .h5 file using the Yell format
        """
        file = h5py.File(path, "r")
        intensities = np.array(file["data"])
        frac_hkl_max = -np.array(file["lower_limits"])
        super_cells = np.round(1 / np.array(file["step_sizes"]))
        file.close()
        return cls(frac_hkl_max, intensities, super_cells)

    @classmethod
    def generate_from_mmcif(cls, path: str, supercells):
        """
        runs gemmi on the file provided and parses the input
        """
        string = get_sf_string(path)
        if not string:
            return
        int_hkl_max, intesities = Diffraction.bring_into_shape(*parse_sf_string(string))
        return cls(int_hkl_max / supercells, intesities, supercells)


def read_sf_file(path: str) -> tuple[np.ndarray, np.ndarray]:
    """
    reads a .sf file
    """
    with open(path, "r", encoding="utf8") as file:
        string = file.read()
    return parse_sf_string(string)


def parse_sf_string(string: str) -> tuple[np.ndarray, np.ndarray]:
    """
    parses the string from an .sf file
    """
    lines = string.splitlines()

    hkls = []
    intensities = []

    for line in lines:
        numbers = re.split(r"\)?\s+", line.strip()[1:])
        hkl = [int(n) for n in numbers[:3]]
        abs_val = float(numbers[3])
        # phase = float(numbers[4])
        intensities.append(abs_val)
        hkls.append(hkl)

    return np.array(hkls, dtype=np.int32), np.array(intensities) ** 2


def get_sf_string(mmcif_file: str) -> str:
    """
    runs gemmi sfcalc on the provided file and returns the output as a string
    """
    try:
        result = subprocess.run(
            ["gemmi", "sfcalc", "--dmin=1", mmcif_file],
            stdout=subprocess.PIPE,
            check=True,
        )
        return result.stdout.decode()
    except subprocess.CalledProcessError:
        print(f"failed to run gemmi on {mmcif_file}")
        return None


def get_runs() -> list[str]:
    """
    returns a list of the names of the runs
    """
    names = []
    for name in os.listdir("mmcif"):
        if os.path.isdir(f"mmcif/{name}"):
            names.append(name)
    return names


def get_file_names(run: str) -> list[str]:
    """
    returns a list of the values used in the run
    """
    names = os.listdir(f"mmcif/{run}")
    return list(map(lambda string: string.removesuffix(".mmcif"), names))


def main():
    from matplotlib import pyplot as plt

    run = get_runs()[0]
    name = get_file_names(run)[10]
    with open(f"csv/{run}.csv", mode="r", encoding="utf8") as file:
        file.readline()
        supercells = int(file.readline().split(" ")[0])
    diffraction = Diffraction.generate_from_mmcif(
        f"mmcif/{run}/{name}.mmcif", np.array([supercells] * 3)
    )
    diffraction.save_yell("out.h5")
    # while True:
    #     l_value = float(input("plot l section\n"))
    #     fig, ax = plt.subplots()
    #     diffraction.plot_l_section(fig, ax, l_value)
    #     plt.show()


if __name__ == "__main__":
    main()
    from matplotlib import pyplot as plt
    # name = "test2"
    # diffraction = Diffraction.add_from_files([f"{name}.sf"], np.array([1, 1, 1]))
    # diffraction.save_yell(f"{name}.h5")
    # while True:
    #     l_value = float(input("plot l section\n"))
    #     fig, ax = plt.subplots()
    #     diffraction.plot_l_section(fig, ax, l_value)
    #     plt.show()
