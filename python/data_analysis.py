"""
This module contains function to read and work with cif files gemmi outputs and the yell format
"""
import re
import numpy as np
import h5py


class Diffraction:
    """
    A class for holding accessing and converting Diffraction data
    """

    def __init__(
        self,
        frac_hkl_max: tuple[float, float, float],
        intensities: np.ndarray,
        super_cells=1,
    ):
        self.hkl_max = np.array(frac_hkl_max)
        self.intensities = intensities
        self.super_cells = np.array([super_cells] * 3)

    @staticmethod
    def __read_sf_file(path: str) -> tuple[np.ndarray, np.ndarray]:
        """
        reads a sf file
        """
        with open(path, "r", encoding="utf8") as file:
            lines = file.readlines()

        hkls = []
        intensities = []

        for line in lines:
            numbers = re.split(r"\)?\s+", line.strip()[1:])
            hkl = [int(n) for n in numbers[:3]]
            abs_val = float(numbers[3])
            # phase = float(numbers[4])
            intensities.append(abs_val)
            hkls.append(hkl)

        return np.array(hkls, dtype=np.int32), np.array(intensities) ** 2

    @classmethod
    def add_from_files(cls, paths: list[str]):
        """
        reads the list of sf files provided and adds the values
        failes if the (hkl) have different ranges
        """
        first_hkl, summed_intensities = Diffraction.__read_sf_file(paths[0])
        for path in paths[1:]:
            hkl, intensities = Diffraction.__read_sf_file(path)
            assert (first_hkl == hkl).all()
            summed_intensities += intensities
        intensities, hkl_max = Diffraction.bring_into_shape(
            first_hkl, summed_intensities
        )
        return cls(hkl_max, intensities)

    @staticmethod
    def bring_into_shape(
        integer_hkls: np.ndarray, intensities: np.ndarray
    ) -> tuple[np.ndarray, tuple[int, int, int]]:
        """
        Takes the integer hkl and intensitied as generated by gemmi
        and puts the intensities into the correct shape
        """
        hkl_max = np.amax(np.abs(integer_hkls), axis=0)
        for val in hkl_max:
            assert val > 0

        h_max, k_max, l_max = hkl_max
        new_intensities = np.empty(hkl_max * 2 + 1)
        new_intensities[:] = np.nan
        for (h, k, l), intensitiy in zip(integer_hkls, intensities):
            new_intensities[h_max + h, k_max + k, l_max + l] = intensitiy
            new_intensities[h_max - h, k_max - k, l_max - l] = intensitiy
        return new_intensities, (h_max, k_max, l_max)

    def has_nan(self) -> bool:
        """
        checks if the diffraction data has nan
        """
        return np.isnan(self.intensities).all()

    def plot_l_section(self, fig, ax, l_value=0):
        """
        plots an l-section if the diffraction data
        """
        l_value = 1  # of the section to draw
        h_max, k_max, l_max = self.hkl_max
        section = self.intensities[:, :, l_max + l_value]

        im = ax.imshow(
            section,
            extent=[
                -h_max / self.super_cells[0],
                h_max / self.super_cells[0],
                -k_max / self.super_cells[1],
                k_max / self.super_cells[1],
            ],
            cmap="gray",
        )
        fig.colorbar(im)
        fig.tight_layout()

    def save_yell(self, path):
        """
        saves the diffraction pattern into the yell format (a .h5 file)
        """
        output = h5py.File(path, "w")
        output["data"] = self.intensities  # the data
        output["format"] = b"Yell 1.0"  # formatting string
        # whether the data is in real or reciprocal space. Scattering data is in reciprocal space
        output["is_direct"] = 0
        output["lower_limits"] = (
            -self.hkl_max / self.super_cells
        )  # the smallest hkl index for this dataset
        output["step_sizes"] = 1 / self.super_cells
        output["unit_cell"] = [5.17, 5.17, 5.17, 90, 90, 90]
        output.close()
